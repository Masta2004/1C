#include <algorithm>
#include <iostream>
#include <queue>
#include <vector>

class Graph {
 public:
  Graph() = default;

  explicit Graph(std::vector<std::vector<int>>& graph) : size_(graph.size()), graph_(graph) {
  }

  explicit Graph(int size) : size_(size), graph_(size + 1) {
  }

  void AddEdge(int u, int v) {
    graph_[u].push_back(v);
    graph_[v].push_back(u);
  }

  std::vector<int> BFS(int from, int to) {
    std::vector<int> parent(size_ + 1, -1);
    std::vector<bool> condition(size_ + 1, false);
    condition[from] = true;
    std::queue<int> visited;
    visited.push(from);
    std::vector<int> dist(size_ + 1, 100000);
    while (!visited.empty()) {
      int vertex = visited.front();
      visited.pop();
      for (size_t i = 0; i < graph_[vertex].size(); i++) {
        int t = graph_[vertex][i];
        if (!condition[t]) {
          condition[t] = true;
          visited.push(t);
          dist[t] = dist[vertex] + 1;
          parent[t] = vertex;
        }
      }
    }
    std::vector<int> way;
    if (!condition[to]) {
      return way;
    }
    for (int i = to; i != -1; i = parent[i]) {
      way.push_back(i);
    }
    std::reverse(way.begin(), way.end());
    return way;
  }

 private:
  int size_;
  std::vector<std::vector<int>> graph_;
};

int main() {
  int number_of_vertex;
  int number_of_edge;
  std::cin >> number_of_vertex >> number_of_edge;
  int from;
  int to;
  std::cin >> from >> to;
  Graph graph(number_of_vertex);
  for (int i = 0; i < number_of_edge; i++) {
    int u;
    int v;
    std::cin >> u >> v;
    graph.AddEdge(u, v);
  }
  std::vector<int> way;
  way = graph.BFS(from, to);
  if (way.empty()) {
    std::cout << -1;
    return 0;
  }
  std::cout << way.size() - 1 << '\n';
  for (size_t i = 0; i < way.size(); i++) {
    std::cout << way[i] << ' ';
  }
  return 0;
}
