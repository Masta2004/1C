# 1C
Отбор на кафедру 1С

Понимание правил игры:
1. За раз можно переложить лишь одну карту (а не как в пауке все упорядоченные).
2. Карту меньшего номинала можно переложить на карту ЛЮБОГО большего номинала.
3. Собранный набор может лежать на других картах. При этом его тоже можно убрать.

Идеи:
1. Пасьянс не сходится, если есть "барьер". Под барьером подразумевается ряд одинаковых по номиналу карт (не обязательно на одном уровне) таких, что над ними лежат только карты меньшего номинала. В таком случае, чтобы не происходило на "поверхности", это не даст возможности переместить "барьерные" карты. Исключением будет такой расклад, при котором под одной из барьерных карт лежит уже упорядоченный набор и только он. То есть если барьерной картой является дама, то под ней первым на столе лежит туз, далее король, потом эта дама.
   Реализация:
   1. Ввод в виде двумерного массива А размера 8х9 (8 столбцов и 9 строк).
   2. Заводим массив В А размера 8х9 (8 столбцов для каждой кучки и 9 строк для каждого номинала карт), заполненный нулями. Проверяем, что в каждой кучке присутствуют карты всех мастей. При проходе        
      по А на каждом шаге увеличиваем на 1 число в соответствующей ячейке В. После заполнения исключаем номиналы, присутствующие не во всех кучках. Остальные номиналы "в лоб" (начиная со старших 
      номиналов) проверяем на "барьерность".
2. Задача напоминает Ханойские башни, но с хаотично разбросанными в начале кольцами (большое кольцо -- большой номинал, маленькое -- маленький).
3. Хочется решать задачу с помощью графов и переходов между состояниями.
   1. Тогда сходимость пасьянса будет равносильна наличию пути из начального расположения карт в выигрышное (искать его будем через BFS, например -- мой код этого алгоритма прилагаю), а минимальное количество ходов будет равно длине                  кратчайшего пути. Но состояний слишком много (экспоненциально от количества карт, что-то около 10^21).
   2. Граф состояний и переходов между ними строится заранее и хранится в памяти. Далее при каждом запросе пользователя используем уже готовый граф.
   3. При создании графа состояний каждое состояние будем хэшировать (так как хранить массивы 8х9 слишком затратно по памяти).
   4. Для учета возможности положить любую карту на пустое место (после сбрасывания сложенных в нужном порядке карт) можно добавить в начало каждой кучки фиктивную карту "Джокера", номинал которой будет 
      больше номинала туза. Например, при кодировании следующим образом 6 --> 1, 7 --> 2, 8 --> 3, ... K --> 8, T --> 9 добавить карту с кодом 10. Эта карта всегда будет снизу и никуда не будет перемещена.
   5. Чтобы поймать ситуацию, в которой собран упорядоченный набор от Т до 6, можно для каждой карты хранить дополнительное поле. В этом поле будет лежать ранг карты. То есть какой под ней максимальный,         содержащий ее, упорядоченный набор. При каждом ходе это поле у перекладываемой карты должно обновляться. Если карту переложили на карту номинала на 1 меньше, то ее ранг становиться на единицу              больше, чем у карты, на которую ее положили. Если номинал перкладываемой карты не "соседний" то он становится равным 1. Если в какой-то момент ранг 6ки становится равным 9, то верхние 9 карт этой          кучки  сбрасываются. Изначально ранги просчитываются, начиная с нижних карт.
4. Еще один вариант --- решать с помощью моделирования игры. То есть определять возможные ходы и перебирать их. Чтобы не уходить в циклы, можно ввести ограничение на количество ходов, за которое игра должна кончится (например 100 или 200 --- больше игроку все равно надоест). Если попадаем в ситуацию, в которой нет допустимых ходов (это легко проверяется, так как возможно только если все карты сверху одного номинала) или мы исчерпали лимит, то отматываем назад (по принципу DFS -- мой код этого алгоритма прилагаю). Для того, чтобы можно было отматывать, будем хранить историю ходов (после отмотки история затирается, чтобы не захламлять память. Также память, отведенная на хранение истории постоянна, так как количество ходов ограничено). Но в таком случае могут быть повторения, что приведет к увеличению времени работы алгоритма. Избежать повторений поможет раскраска вершин как в DFS (белые = непосещенные, серые = посещенные, но не полностью отработанные, черные = посещенные и полностью отработанные).

Программирование обоих вариантов требует большого объема памяти и много времени (в случае создания графа состояний).
В жизни проще создать базу псевдослучайных раскладок с помощью "обратной" игры. То есть из конечного состояния идти в начальное.
